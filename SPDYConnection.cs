using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SPDY
{
	/// <summary>Represents a connection using the SPDY protocol.</summary>
	public sealed class SPDYConnection : IDisposable
	{
		/// <summary>Initializes a new <see cref="SPDYConnection"/> using a bidirectional network stream.</summary>
		/// <param name="networkStream">A network <see cref="Stream"/> that can be read and written simultaneously</param>
		/// <param name="version">The SPDY version to use. Only 3.1 is currently supported.</param>
		public SPDYConnection(Stream networkStream, string version) : this(networkStream, networkStream, version) { }

		/// <summary>Initializes a new <see cref="SPDYConnection"/> using separate read and write streams.</summary>
		/// <param name="readStream">The <see cref="Stream"/> from which frames should be read</param>
		/// <param name="writeStream">The <see cref="Stream"/> to hich frames should be written</param>
		/// <param name="version">The SPDY version to use. Only 3.1 is currently supported.</param>
		public SPDYConnection(Stream readStream, Stream writeStream, string version)
		{
			if(version != "3.1") throw new NotSupportedException($"Version {version} not supported.");
			this.readStream = readStream ?? throw new ArgumentNullException(nameof(readStream));
			this.writeStream = writeStream ?? throw new ArgumentNullException(nameof(writeStream));
			compressor.SetDictionary(zlibDictv3); // the zlib compression used by SPDY must be initialized with a known dictionary
			decompressor.SetDictionary(zlibDictv3);
		}

		/// <summary>Gets whether the connection is currently known to be open. This property may not be updated until the next attempt
		/// to read or write.
		/// </summary>
		public bool IsOpen { get; private set; } = true;

		/// <inheritdoc/>
		public void Dispose() => CloseCore(); // close the connection

		/// <summary>Compresses headers for use in a <see cref="SPDYFrameType.Headers"/>, <see cref="SPDYFrameType.Reply"/>, or
		/// <see cref="SPDYFrameType.Stream"/> frame.
		/// </summary>
		/// <remarks>Because the compressed stream spans all frames written in the connection, only one thread may be compressing headers
		/// at any given time.
		/// </remarks>
		public unsafe byte[] CompressHeaders(IDictionary<string, List<string>> headers)
		{
			byte[] data;
			if(headers == null || headers.Count == 0) // if there are no headers...
			{
				data = new byte[4]; // just compress a zero item count
			}
			else // otherwise, we have headers...
			{
				var ms = new MemoryStream(); // so write them into a memory stream first
				Write(ms, headers.Count); // the first field is the number of headers
				foreach(KeyValuePair<string, List<string>> pair in headers) // for each header
				{
					byte[] bytes = Encoding.UTF8.GetBytes(pair.Key); // the key is a 4-byte length followed by the string data
					Write(ms, bytes.Length);
					ms.Write(bytes, 0, bytes.Length);
					if(pair.Value == null || pair.Value.Count == 0) // if there are no values for the key...
					{
						Write(ms, 0); // write an empty value
					}
					else
					{
						// compute the length of the header values, which will be joined together, separated by zero (NUL) bytes
						Write(ms, pair.Value.Sum(v => Encoding.UTF8.GetByteCount(v)) + pair.Value.Count - 1);
						bool sep = false;
						foreach(string v in pair.Value) // then write each value
						{
							if(sep) ms.WriteByte(0); // and separate them by zero (NUL) bytes
							else sep = true;
							bytes = Encoding.UTF8.GetBytes(v);
							ms.Write(bytes, 0, bytes.Length);
						}
					}
				}
				data = ms.ToArray();
			}
			// now compress the data. use a Sync flush to ensure we get all the output for the block
			return compressor.Transform(data, ZlibFlush.Sync).ToArray();
		}

		/// <summary>Decompresses headers from a <see cref="SPDYFrameType.Headers"/>, <see cref="SPDYFrameType.Reply"/>, or
		/// <see cref="SPDYFrameType.Stream"/> frame.
		/// </summary>
		/// <remarks>Because the compressed stream spans all frames read in the connection, only one thread may be decompressing headers
		/// at any given time.
		/// </remarks>
		public Dictionary<string, List<string>> DecompressHeaders(byte[] data, int index, int length)
		{
			byte[] dec = decompressor.Transform(data, index, length, ZlibFlush.Sync).ToArray(); // decompress it
			int count = SPDYFrame.ReadInt(dec, 0), i = 4; // the first field is the number of headers
			var headers = new Dictionary<string, List<string>>(count);
			while(--count >= 0) // for each header...
			{
				int byteCount = SPDYFrame.ReadInt(dec, i); // read the key length
				string key = Encoding.UTF8.GetString(dec, i+4, byteCount); // and the key itself
				i = i + 4 + byteCount;
				byteCount = SPDYFrame.ReadInt(dec, i); // now read the values length
				i += 4;
				var values = new List<string>();
				for(int end = i+byteCount; i < end; )
				{
					int sep = i; // scan for the end of the current value
					while(sep < end && data[sep] != 0) sep++; // if we get to the end or see a NUL byte, stop
					values.Add(Encoding.UTF8.GetString(dec, i, sep-i)); // add the value
					i = sep; // and move past it
					if(sep < end) i++; // if we stopped at a NUL byte, move past that too
				}
				headers[key] = values;
			}
			return headers;
		}

		/// <summary>Returns the next <see cref="SPDYFrame"/> from the network, or an invalid frame (with <see cref="SPDYFrame.IsValid"/>
		/// set to false) if no more frames are available.
		/// </summary>
		/// <exception cref="EndOfStreamException">Thrown if the connection ran out of data the middle of the frame</exception>
		/// <exception cref="InvalidOperationException">Thrown if <see cref="IsOpen"/> is false</exception>
		/// <remarks>Only one thread is allowed to be sending frames at a time. If the <paramref name="cancelToken"/> is canceled in the
		/// middle of reading the frame, the connection may be closed.
		/// </remarks>
		public async Task<SPDYFrame> ReceiveFrameAsync(CancellationToken cancelToken = default)
		{
			AssertOpen();
			try
			{
				while(BufferBytes < SPDYFrame.HeaderSize) // if we don't have a full header in the buffer...
				{
					cancelToken.ThrowIfCancellationRequested();
					if(bufferIndex != 0 && bufferEnd != bufferIndex) // if there's some data in the buffer but not at the beginning...
					{
						Array.Copy(buffer, bufferIndex, buffer, 0, BufferBytes); // shift it to the beginning. it's only a few bytes
						bufferEnd = BufferBytes; // now we're sure to have enough space for the header and some data
						bufferIndex = 0;
					}
					int read = await readStream.ReadAsync(buffer, bufferEnd, buffer.Length-bufferEnd, cancelToken).ConfigureAwait(false);
					if(read == 0) // if we've reached the end of the stream...
					{
						CloseCore(); // consider the connection closed
						return default(SPDYFrame); // and return an invalid frame
					}
					bufferEnd += read;
				}

				cancelToken.ThrowIfCancellationRequested();
				var frame = new SPDYFrame(buffer, bufferIndex); // read the frame header from the buffer
				Consume(SPDYFrame.HeaderSize);
				for(int i = 0; i < frame.DataLength;) // and read the frame data
				{
					if(BufferBytes == 0) // if there's no more data in the buffer...
					{
						// refill it. if an error occurs while reading, the state is corrupted because we don't support resuming a frame
						// on the next call. in that case, just close the connection
						try { bufferEnd = await readStream.ReadAsync(buffer, 0, buffer.Length, cancelToken).ConfigureAwait(false); }
						catch { CloseCore(); throw; }
						if(bufferEnd == 0) // if no more data is available...
						{
							CloseCore(); // consider the connection closed
							throw new EndOfStreamException("Unexpected end of stream.");
						}
					}
					int toCopy = Math.Min(BufferBytes, frame.DataLength-i); // we have some data in the buffer, so copy it into the frame
					Array.Copy(buffer, bufferIndex, frame.Data, i, toCopy);
					Consume(toCopy);
					i += toCopy;
				}
				return frame;
			}
			catch(IOException) // an IO exception may be thrown if the underlying network connection is closed
			{
				CloseCore();
			}
			catch(ObjectDisposedException) // an ObjectDisposedException may also be thrown in that case
			{
				CloseCore();
			}
			catch(System.Net.Sockets.SocketException) // as might a SocketException
			{
				CloseCore();
			}
			return default(SPDYFrame); // if an error occurs, return an invalid frame
		}

		/// <summary>Sends a <see cref="SPDYFrame"/> on the network.</summary>
		/// <exception cref="InvalidOperationException">Thrown if the connection was closed (<see cref="IsOpen"/> is false) or if the
		/// connection becomes closed while sending the frame
		/// </exception>
		/// <remarks>Only one thread is allowed to be sending frames at a time. If the <paramref name="cancelToken"/> is canceled in the
		/// middle of sending the frame, the connection may be closed.
		/// </remarks>
		public async Task SendFrameAsync(SPDYFrame frame, CancellationToken cancelToken = default)
		{
			if(!frame.IsValid) throw new ArgumentException("The frame is not valid.");
			AssertOpen();
			cancelToken.ThrowIfCancellationRequested();
			frame.CopyHeaderTo(writeBuffer); // get the header bytes
			try
			{
				await writeStream.WriteAsync(writeBuffer, 0, SPDYFrame.HeaderSize, cancelToken).ConfigureAwait(false); // send the header
				await writeStream.WriteAsync(frame.Data, 0, frame.DataLength, cancelToken).ConfigureAwait(false); // and then the data
			}
			catch(Exception ex) // if an exception occurred, we don't know if the state of the stream has been corrupted
			{
				CloseCore(); // so stay on the safe side and close the connection
				if(ex is ObjectDisposedException || ex is IOException || ex is System.Net.Sockets.SocketException) // if the connection was closed...
				{
					throw new InvalidOperationException("The connection was closed.", ex); // normalize to a known exception
				}
				throw; // for other exceptions (e.g. cancellation), rethrow
			}
		}

		/// <summary>Gets the number of bytes stored in the read buffer.</summary>
		int BufferBytes => bufferEnd - bufferIndex;

		void AssertOpen()
		{
			if(!IsOpen) throw new InvalidOperationException("The connection is closed.");
		}

		void CloseCore()
		{
			IsOpen = false;
			readStream.Dispose();
			if(readStream != writeStream) writeStream.Dispose();
		}

		/// <summary>Removes the given number of bytes from the read buffer.</summary>
		void Consume(int byteCount)
		{
			bufferIndex += byteCount;
			if(bufferIndex == bufferEnd) bufferIndex = bufferEnd = 0; // if the buffer became empty, do the next read from the beginning
		}

		readonly Stream readStream, writeStream;
		readonly byte[] buffer = new byte[4096], writeBuffer = new byte[SPDYFrame.HeaderSize]; // the read and write buffers
		readonly ZlibCodec compressor = new ZlibCodec(windowBits: 11); // use a reduced window size (2KB) because headers tend to be small
		readonly ZlibCodec decompressor = new ZlibCodec(CompressionMode.Decompress);
		int bufferIndex, bufferEnd; // the read and write indexes within the read buffer

		// Writes a value into a MemoryStream in network (big-endian) order.
		static void Write(MemoryStream ms, int value) => Write(ms, (uint)value);
		static void Write(MemoryStream ms, uint value)
		{
			ms.WriteByte((byte)(value >> 24));
			ms.WriteByte((byte)(value >> 16));
			ms.WriteByte((byte)(value >> 8));
			ms.WriteByte((byte)value);
		}

		#region zlibDictv3
		/// <summary>The initial compression dictionary mandated by the SPDY 3 specification.</summary>
		static readonly byte[] zlibDictv3 = new byte[1423]
		{
			0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68,
			0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70, 0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70,
			0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05,
			0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, 0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00,
			0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,
			0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,
			0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c,
			0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70,
			0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00,
			0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68,
			0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63,
			0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f,
			0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74,
			0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74,
			0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10,
			0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
			0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67,
			0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f,
			0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
			0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
			0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
			0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00, 0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00,
			0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00, 0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
			0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66,
			0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69,
			0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f,
			0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d,
			0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00,
			0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d,
			0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65,
			0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65,
			0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,
			0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00,
			0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00, 0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79,
			0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,
			0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,
			0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00,
			0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72,
			0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65,
			0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00, 0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c,
			0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65,
			0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61,
			0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74,
			0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00,
			0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77,
			0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00,
			0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00,
			0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30,
			0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,
			0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72,
			0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73,
			0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65,
			0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69,
			0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32, 0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35,
			0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30, 0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33,
			0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37, 0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30,
			0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34, 0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31,
			0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31, 0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34,
			0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34, 0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e,
			0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,
			0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20,
			0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f,
			0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d, 0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34,
			0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30,
			0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30,
			0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64, 0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e,
			0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65,
			0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f,
			0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65,
			0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
			0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46,
			0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41, 0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a,
			0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41, 0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20,
			0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20, 0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30,
			0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e, 0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57,
			0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c, 0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61,
			0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20, 0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b,
			0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61,
			0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67,
			0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67, 0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,
			0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,
			0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c,
			0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74,
			0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c,
			0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65,
			0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65, 0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64,
			0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63,
			0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69, 0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d,
			0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a, 0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e
		};
		#endregion
	}
}
